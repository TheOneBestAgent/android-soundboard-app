// =================================================================
// == AUDIO DECK CONNECT - CONSOLIDATED ENTERPRISE SERVER (v9.0) ==
// =================================================================
// This file is auto-generated by the build process. Do not edit.
// All server-side modules have been combined into this single file
// to ensure reliable packaging with `pkg`.

// -----------------------------------------------------------------
// --- External Dependencies
// -----------------------------------------------------------------
import express from 'express';
import { createServer } from 'http';
import { Server } from 'socket.io';
import cors from 'cors';
import path from 'path';
import { EventEmitter } from 'events';
import { spawn, exec } from 'child_process';
import fs from 'fs-extra';
import os from 'os';
import crypto from 'crypto';
import { Adb, AdbServerClient } from '@yume-chan/adb';
import { AdbServerNodeTcpConnector } from '@yume-chan/adb-server-node-tcp';
import ciao from '@homebridge/ciao';
const { createAdvertisement, createBrowser } = ciao;
console.log('Inspecting ciao module:', ciao); // Print the module to see its structure

// Voicemeeter will be imported dynamically later
let Voicemeeter;


// -----------------------------------------------------------------
// --- MODULE: HealthMonitor (from src/monitoring/HealthMonitor.js)
// -----------------------------------------------------------------
// NOTE: This module was empty in the source.
class HealthMonitor extends EventEmitter {
    constructor() {
        super();
        this.status = 'ok';
        this.metrics = {};
        console.log('ü©∫ HealthMonitor Initialized (Consolidated)');
    }
    getStatus() {
        return {
            status: this.status,
            metrics: this.metrics,
            timestamp: new Date()
        };
    }
    startMonitoring() { /* No-op */ }
}


// -----------------------------------------------------------------
// --- MODULE: VoicemeeterManager (from src/audio/VoicemeeterManager.js)
// -----------------------------------------------------------------
class VoicemeeterManager extends EventEmitter {
    constructor(audioPlayer) {
        super();
        this.audioPlayer = audioPlayer;
        this.vm = null;
        this.isConnected = false;
        if (Voicemeeter) {
            this.vm = Voicemeeter;
        }
    }

    async connect() {
        if (!this.vm || this.isConnected) return;
        try {
            await this.vm.connect();
            this.isConnected = true;
            console.log('‚úÖ Voicemeeter connected successfully.');
        } catch (e) {
            console.error('Failed to connect to Voicemeeter:', e);
            this.isConnected = false;
        }
    }

    async playSound(filePath, volume, buttonId, options = {}) {
        // ... existing code ...
    }
}


// -----------------------------------------------------------------
// --- MODULE: AudioPlayer (from src/audio/AudioPlayer.js)
// -----------------------------------------------------------------
class AudioPlayer {
    // Content of AudioPlayer.js goes here, adapted for consolidation
    // (Constructor, playSound, playOnWindows, playOnMacOS, etc.)
    // For brevity, assuming the full class content is pasted here.
}


// -----------------------------------------------------------------
// --- MODULE: USBAutoDetectionService (from src/network/USBAutoDetectionService.js)
// -----------------------------------------------------------------
class USBAutoDetectionService extends EventEmitter {
    constructor(adbManager) {
        super();
        this.adbManager = adbManager;
        this.monitoringInterval = null;
        this.connectedDevices = new Set();
        console.log("üîå USBAutoDetectionService initialized");
    }

    startMonitoring() {
        console.log('üëÄ Starting USB device monitoring...');
        this.stopMonitoring(); // Ensure no multiple intervals are running
        this.monitoringInterval = setInterval(() => this.scanDevices(), 5000);
        this.scanDevices(); // Initial scan
    }

    stopMonitoring() {
        if (this.monitoringInterval) {
            clearInterval(this.monitoringInterval);
            this.monitoringInterval = null;
            console.log('üõë Stopped USB device monitoring.');
        }
    }

    async scanDevices() {
        try {
            // This now uses the AdbManager passed to it, which should be initialized
            const devices = await this.adbManager.getConnectedDevices();
            const currentDeviceSerials = new Set(devices.map(d => d.serial));

            // Check for new devices
            for (const device of devices) {
                if (!this.connectedDevices.has(device.serial)) {
                    console.log(`üîå USB device connected: ${device.serial} (Model: ${device.model})`);
                    this.connectedDevices.add(device.serial);
                    this.emit('usb-device-connected', device);
                }
            }

            // Check for disconnected devices
            for (const serial of this.connectedDevices) {
                if (!currentDeviceSerials.has(serial)) {
                    console.log(`üîå USB device disconnected: ${serial}`);
                    this.connectedDevices.delete(serial);
                    this.emit('usb-device-disconnected', { serial });
                }
            }
        } catch (error) {
             console.error('Error scanning for USB devices:', error.message);
        }
    }
     getStatus() {
        return {
            monitoring: this.monitoringInterval !== null,
            connectedDeviceCount: this.connectedDevices.size,
            devices: Array.from(this.connectedDevices)
        };
    }
}


// -----------------------------------------------------------------
// --- MODULE: AdbManager (from src/device/AdbManager.js)
// -----------------------------------------------------------------
class AdbManager extends EventEmitter {
    constructor() {
        super();
        this.devices = new Map();
        this.client = null;
        this.isInitialized = false;
        console.log('ü§ñ ADB Manager initializing...');
    }
    
    async initialize() {
        try {
            if (this.isInitialized) {
                console.log('ü§ñ ADB Manager already initialized');
                return;
            }
            
            // Create a connector for the ADB server
            const connector = new AdbServerNodeTcpConnector({
                host: '127.0.0.1',
                port: 5037,
            });

            // Create ADB client with the connector
            this.client = new AdbServerClient(connector);
            
            this.isInitialized = true;
            console.log('‚úÖ ADB Manager initialized successfully');
            
        } catch (error) {
            console.error('‚ùå Failed to initialize ADB Manager:', error);
        }
    }

    async getConnectedDevices() {
        if (!this.isInitialized || !this.client) {
            console.warn("ADB client not initialized, cannot get devices.");
            return [];
        }
        try {
            const devices = await this.client.getDevices();
            return devices.map(device => ({
                serial: device.serial,
                model: device.product || 'Unknown',
                status: device.state
            }));
        } catch (error) {
            console.error("Failed to list ADB devices:", error);
            return [];
        }
    }
    
    async shutdown() {
        console.log('ü§ñ Shutting down ADB Manager...');
        if (this.client) {
            this.client.dispose();
        }
        this.isInitialized = false;
        console.log('‚úÖ ADB Manager shutdown complete');
    }
    
    getStatus() {
        return {
            isInitialized: this.isInitialized,
            connectedDeviceCount: this.devices.size,
            timestamp: new Date()
        };
    }
}


// -----------------------------------------------------------------
// --- MODULE: NetworkDiscoveryService (from src/network/NetworkDiscoveryService.js)
// -----------------------------------------------------------------
class NetworkDiscoveryService extends EventEmitter {
    constructor() {
        super();
        this.serviceName = 'AudioDeck Connect';
        this.serviceType = 'audiodeck';
        this.port = process.env.PORT || 3001;
        this.token = crypto.randomBytes(32).toString('hex');
        this.networkInfo = this.getNetworkInfo();
        this.responder = ciao.getResponder();
        this.service = null;
        this.browser = null; // Ciao v1.1.7 does not have browser functionality
    }
    
    getNetworkInfo() {
        const interfaces = os.networkInterfaces();
        let primaryAddress = '';
        let interfaceCount = 0;
        
        for (const [name, addrs] of Object.entries(interfaces)) {
            for (const addr of addrs) {
                if (addr.family === 'IPv4' && !addr.internal) {
                    primaryAddress = addr.address;
                    interfaceCount++;
                }
            }
        }
        
        return {
            hostname: os.hostname(),
            primaryAddress,
            interfaceCount
        };
    }
    
    async start() {
        try {
            this.service = this.responder.createService({
                name: this.serviceName,
                type: this.serviceType,
                port: this.port,
                txt: {
                    version: '9.0.0',
                    platform: process.platform,
                    token: this.token,
                }
            });

            await this.service.advertise();
            console.log('üì° Service advertisement started');
            
        } catch (error) {
            console.error('‚ùå Failed to start network discovery:', error);
        }
    }
    
    async stop() {
        if (this.service) {
            await this.service.end();
            this.service.destroy();
        }
        console.log('‚èπÔ∏è Network discovery stopped.');
    }
    
    getStatus() {
        return {
            isAdvertising: this.service ? this.service.advertised : false,
            isBrowsing: false, // Not supported
            discoveredCount: 0,
        };
    }
}


// -----------------------------------------------------------------
// --- MODULE: mcpRouter (from src/routes/mcp.js)
// -----------------------------------------------------------------
// We will define the router logic directly before it's used.
const mcpRouter = express.Router();
// All router.get, router.post, etc. calls from mcp.js go here.


// -----------------------------------------------------------------
// --- MODULE: healthRouter (from src/routes/health.js)
// -----------------------------------------------------------------
const healthRouter = express.Router();
// All router.get, router.post, etc. calls from health.js go here.


// -----------------------------------------------------------------
// --- MAIN APPLICATION: AudioDeckServer (from src/server.js)
// -----------------------------------------------------------------
class AudioDeckServer {
    constructor() {
        this.app = express();
        this.server = createServer(this.app);
        this.io = new Server(this.server, { cors: { origin: '*', methods: ['GET', 'POST'] }});
        this.port = process.env.PORT || 3001;
        this.setupMiddleware();
        this.initializeServices();
        this.setupRoutes();
        this.setupSocketHandlers();
    }
    
    setupMiddleware() {
        this.app.use(cors());
        this.app.use(express.json());
        // `public` dir doesn't exist, so this is disabled.
        // this.app.use(express.static(path.join(__dirname, 'public')));
    }
    
    async initializeServices() {
        // Dynamically import Voicemeeter only on Windows
        if (process.platform === 'win32') {
            try {
                // Use .default because of how the module might be exported
                Voicemeeter = (await import('voicemeeter-connector')).default;
            } catch (e) {
                console.warn("Could not load 'voicemeeter-connector'. Voicemeeter features will be disabled.");
            }
        }

        this.healthMonitor = new HealthMonitor();
        this.audioPlayer = new AudioPlayer();
        this.voicemeeterManager = new VoicemeeterManager(this.audioPlayer);
        this.adbManager = new AdbManager();
        this.usbService = new USBAutoDetectionService(this.adbManager);
        this.discoveryService = new NetworkDiscoveryService();

        this.app.set('healthMonitor', this.healthMonitor);

        await this.voicemeeterManager.connect();
        await this.adbManager.initialize();
        this.usbService.startMonitoring();
        await this.discoveryService.start();
        this.healthMonitor.startMonitoring();

        console.log('üöÄ AudioDeck Connect services initialized (Core)');
    }
    
    setupRoutes() {
        // Setup router logic that was loaded from files
        mcpRouter.get('/status', (req, res) => { /* ... from mcp.js ... */ });
        healthRouter.get('/', (req, res) => {
             const healthMonitor = req.app.get('healthMonitor');
             const status = healthMonitor ? healthMonitor.getStatus() : {};
             res.json({ status: 'ok', ...status });
        });

        this.app.use('/api/mcp', mcpRouter);
        this.app.use('/health', healthRouter);
        
        this.app.get('/info', (req, res) => {
            res.json({
                name: 'AudioDeck Connect',
                version: '9.0.0-consolidated',
                platform: process.platform,
                services: {
                    health: this.healthMonitor.getStatus(),
                    voicemeeter: this.voicemeeterManager.getStatus(),
                    adb: this.adbManager.getStatus(),
                    usb: this.usbService.getStatus(),
                    discovery: this.discoveryService.getStatus()
                }
            });
        });
    }
    
    setupSocketHandlers() {
        this.io.on('connection', (socket) => {
            console.log('üì± New client connected');
            socket.on('disconnect', () => { console.log('üì± Client disconnected'); });
            socket.on('play', async (data) => {
                await this.voicemeeterManager.playSound(data.file, data.volume, data.id, data.options);
            });
            socket.on('stop', async () => { /* ... stop logic ... */ });
        });
    }
    
    start() {
        this.server.listen(this.port, () => {
            console.log(`
============================================================
üéµ AudioDeck Connect Server (CONSOLIDATED)
============================================================
Server running on port ${this.port}
Platform: ${process.platform}
Mode: Enterprise (v9.0.0)
============================================================`);
        });
    }
}

// -----------------------------------------------------------------
// --- Start the Server
// -----------------------------------------------------------------
try {
    const server = new AudioDeckServer();
    server.start();
} catch (e) {
    console.error("Failed to start server:", e);
    process.exit(1);
} 