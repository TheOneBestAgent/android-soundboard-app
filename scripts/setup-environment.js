#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const os = require('os');
const { execSync, spawn } = require('child_process');

class CrossPlatformSetup {
    constructor() {
        this.platform = this.detectPlatform();
        this.projectRoot = path.resolve(__dirname, '..');
        this.config = this.loadPlatformConfig();
        
        console.log(`ðŸ”§ Setting up environment for ${this.platform}`);
    }
    
    detectPlatform() {
        const platform = os.platform();
        switch (platform) {
            case 'win32': return 'windows';
            case 'darwin': return 'darwin';
            case 'linux': return 'linux';
            default: 
                console.warn(`âš ï¸ Unknown platform: ${platform}, defaulting to linux`);
                return 'linux';
        }
    }
    
    loadPlatformConfig() {
        const configPath = path.join(this.projectRoot, 'platform-config.json');
        try {
            const configData = fs.readFileSync(configPath, 'utf8');
            return JSON.parse(configData);
        } catch (error) {
            console.error('âŒ Failed to load platform configuration:', error.message);
            process.exit(1);
        }
    }
    
    expandPath(pathTemplate) {
        if (this.platform === 'windows') {
            // Expand Windows environment variables
            return pathTemplate
                .replace(/%LOCALAPPDATA%/g, process.env.LOCALAPPDATA || '')
                .replace(/%USERPROFILE%/g, process.env.USERPROFILE || '')
                .replace(/%USERNAME%/g, process.env.USERNAME || '')
                .replace(/%JAVA_HOME%/g, process.env.JAVA_HOME || '');
        } else {
            // Expand Unix environment variables
            return pathTemplate
                .replace(/\$HOME/g, os.homedir())
                .replace(/\$JAVA_HOME/g, process.env.JAVA_HOME || '')
                .replace(/\$\{([^}]+)\}/g, (match, varName) => process.env[varName] || '');
        }
    }
    
    findValidPath(pathTemplates) {
        for (const template of pathTemplates) {
            const expandedPath = this.expandPath(template);
            if (fs.existsSync(expandedPath)) {
                return expandedPath;
            }
        }
        return null;
    }
    
    async setupAndroidSDK() {
        console.log('ðŸ“± Setting up Android SDK...');
        
        const platformConfig = this.config.platforms[this.platform];
        const sdkPath = this.findValidPath(platformConfig.sdk.defaultPaths);
        
        if (!sdkPath) {
            console.error('âŒ Android SDK not found. Please install Android Studio or SDK Command Line Tools.');
            console.log('ðŸ“‹ Recommended paths:');
            platformConfig.sdk.defaultPaths.forEach(path => {
                console.log(`   - ${this.expandPath(path)}`);
            });
            return false;
        }
        
        console.log(`âœ… Found Android SDK: ${sdkPath}`);
        return sdkPath;
    }
    
    async setupJDK() {
        console.log('â˜• Setting up JDK...');
        
        const platformConfig = this.config.platforms[this.platform];
        const jdkPath = this.findValidPath(platformConfig.jdk.defaultPaths);
        
        if (!jdkPath) {
            console.error('âŒ JDK 17 not found. Please install OpenJDK 17.');
            console.log('ðŸ“‹ Recommended paths:');
            platformConfig.jdk.defaultPaths.forEach(path => {
                console.log(`   - ${this.expandPath(path)}`);
            });
            return false;
        }
        
        console.log(`âœ… Found JDK: ${jdkPath}`);
        return jdkPath;
    }
    
    async setupADB() {
        console.log('ðŸ”Œ Setting up ADB (Android Debug Bridge)...');
        
        const platformConfig = this.config.platforms[this.platform];
        const adbPath = this.findValidPath(platformConfig.adb.defaultPaths);
        
        if (!adbPath) {
            console.error('âŒ ADB not found. Please install Android SDK Platform Tools.');
            console.log('ðŸ“‹ Expected paths:');
            platformConfig.adb.defaultPaths.forEach(path => {
                console.log(`   - ${this.expandPath(path)}`);
            });
            return false;
        }
        
        console.log(`âœ… Found ADB: ${adbPath}`);
        
        // Test ADB functionality
        try {
            const result = execSync(`"${adbPath}" version`, { encoding: 'utf8' });
            console.log(`ðŸ“± ADB Version: ${result.split('\n')[0]}`);
        } catch (error) {
            console.warn('âš ï¸ ADB test failed:', error.message);
        }
        
        return adbPath;
    }
    
    async createLocalProperties(sdkPath, jdkPath) {
        console.log('ðŸ“ Creating local.properties...');
        
        const localPropsPath = path.join(this.projectRoot, 'local.properties');
        const content = `# Auto-generated by setup-environment.js
# Platform: ${this.platform}
# Generated: ${new Date().toISOString()}

sdk.dir=${sdkPath.replace(/\\/g, '/')}
java.home=${jdkPath.replace(/\\/g, '/')}
`;
        
        try {
            fs.writeFileSync(localPropsPath, content, 'utf8');
            console.log('âœ… local.properties created successfully');
        } catch (error) {
            console.error('âŒ Failed to create local.properties:', error.message);
            return false;
        }
        
        return true;
    }
    
    async setupServerEnvironment(adbPath) {
        console.log('ðŸ–¥ï¸ Setting up server environment...');
        
        const serverEnvPath = path.join(this.projectRoot, 'server', '.env');
        const content = `# Auto-generated by setup-environment.js
# Platform: ${this.platform}
# Generated: ${new Date().toISOString()}

ADB_PATH=${adbPath}
PLATFORM=${this.platform}
NODE_ENV=development
`;
        
        try {
            fs.writeFileSync(serverEnvPath, content, 'utf8');
            console.log('âœ… Server .env file created successfully');
        } catch (error) {
            console.error('âŒ Failed to create server .env file:', error.message);
            return false;
        }
        
        return true;
    }
    
    async installDependencies() {
        console.log('ðŸ“¦ Installing server dependencies...');
        
        try {
            const serverDir = path.join(this.projectRoot, 'server');
            process.chdir(serverDir);
            
            console.log('ðŸ”„ Running npm install...');
            execSync('npm install', { stdio: 'inherit' });
            
            console.log('âœ… Server dependencies installed');
            return true;
        } catch (error) {
            console.error('âŒ Failed to install dependencies:', error.message);
            return false;
        } finally {
            process.chdir(this.projectRoot);
        }
    }
    
    async validateGradleSetup() {
        console.log('ðŸ˜ Validating Gradle setup...');
        
        const platformConfig = this.config.platforms[this.platform];
        const gradleWrapper = path.join(this.projectRoot, platformConfig.gradle.wrapper);
        
        if (!fs.existsSync(gradleWrapper)) {
            console.error(`âŒ Gradle wrapper not found: ${gradleWrapper}`);
            return false;
        }
        
        try {
            console.log('ðŸ”„ Testing Gradle wrapper...');
            const result = execSync(`"${gradleWrapper}" --version`, { 
                encoding: 'utf8',
                cwd: this.projectRoot 
            });
            console.log(`âœ… Gradle version: ${result.split('\n')[2]}`);
            return true;
        } catch (error) {
            console.error('âŒ Gradle test failed:', error.message);
            return false;
        }
    }
    
    async createPlatformScripts() {
        console.log('ðŸ“œ Creating platform-specific scripts...');
        
        const scriptsDir = path.join(this.projectRoot, 'scripts');
        if (!fs.existsSync(scriptsDir)) {
            fs.mkdirSync(scriptsDir, { recursive: true });
        }
        
        // Create build script
        const buildScript = this.platform === 'windows' ? 
            this.createWindowsBuildScript() : 
            this.createUnixBuildScript();
        
        const buildScriptPath = path.join(scriptsDir, 
            this.platform === 'windows' ? 'build.bat' : 'build.sh');
        
        fs.writeFileSync(buildScriptPath, buildScript, 'utf8');
        
        if (this.platform !== 'windows') {
            fs.chmodSync(buildScriptPath, '755');
        }
        
        console.log(`âœ… Build script created: ${buildScriptPath}`);
        return true;
    }
    
    createWindowsBuildScript() {
        return `@echo off
REM Auto-generated Windows build script
echo ðŸ”¨ Building Android Soundboard App (Windows)

REM Clean previous build
echo ðŸ§¹ Cleaning previous build...
call gradlew.bat clean

REM Build debug APK
echo ðŸ“± Building debug APK...
call gradlew.bat assembleDebug

REM Check if build was successful
if exist "app\\build\\outputs\\apk\\debug\\app-debug.apk" (
    echo âœ… Build successful!
    echo ðŸ“± APK location: app\\build\\outputs\\apk\\debug\\app-debug.apk
) else (
    echo âŒ Build failed!
    exit /b 1
)

pause
`;
    }
    
    createUnixBuildScript() {
        return `#!/bin/bash
# Auto-generated Unix build script
echo "ðŸ”¨ Building Android Soundboard App (${this.platform})"

# Clean previous build
echo "ðŸ§¹ Cleaning previous build..."
./gradlew clean

# Build debug APK
echo "ðŸ“± Building debug APK..."
./gradlew assembleDebug

# Check if build was successful
if [ -f "app/build/outputs/apk/debug/app-debug.apk" ]; then
    echo "âœ… Build successful!"
    echo "ðŸ“± APK location: app/build/outputs/apk/debug/app-debug.apk"
else
    echo "âŒ Build failed!"
    exit 1
fi
`;
    }
    
    async run() {
        console.log('ðŸš€ Starting cross-platform environment setup...\n');
        
        const sdkPath = await this.setupAndroidSDK();
        if (!sdkPath) return false;
        
        const jdkPath = await this.setupJDK();
        if (!jdkPath) return false;
        
        const adbPath = await this.setupADB();
        if (!adbPath) return false;
        
        await this.createLocalProperties(sdkPath, jdkPath);
        await this.setupServerEnvironment(adbPath);
        await this.installDependencies();
        await this.validateGradleSetup();
        await this.createPlatformScripts();
        
        console.log('\nðŸŽ‰ Environment setup completed successfully!');
        console.log('\nðŸ“‹ Next steps:');
        console.log('   1. Run the server: cd server && npm start');
        console.log('   2. Build the app: npm run build (or use platform-specific script)');
        console.log('   3. Connect your Android device via USB');
        console.log('   4. Enable USB Debugging in Developer Options');
        
        return true;
    }
}

// Run the setup if this script is executed directly
if (require.main === module) {
    const setup = new CrossPlatformSetup();
    setup.run().then(success => {
        process.exit(success ? 0 : 1);
    }).catch(error => {
        console.error('ðŸ’¥ Setup failed:', error);
        process.exit(1);
    });
}

module.exports = CrossPlatformSetup; 